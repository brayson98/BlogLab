{"ast":null,"code":"import { Injectable, ɵɵdefineInjectable, EventEmitter, Component, NgZone, Input, Output, HostBinding, NgModule } from '@angular/core';\nimport { LinkedList, isBs3 } from 'ngx-bootstrap/utils';\nimport { CommonModule } from '@angular/common';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/common';\n\nfunction CarouselComponent_ol_1_li_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r7 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"li\", 7);\n    ɵngcc0.ɵɵlistener(\"click\", function CarouselComponent_ol_1_li_1_Template_li_click_0_listener() {\n      const restoredCtx = ɵngcc0.ɵɵrestoreView(_r7);\n      const i_r5 = restoredCtx.index;\n      const ctx_r6 = ɵngcc0.ɵɵnextContext(2);\n      return ɵngcc0.ɵɵresetView(ctx_r6.selectSlide(i_r5));\n    });\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const slide_r4 = ctx.$implicit;\n    ɵngcc0.ɵɵclassProp(\"active\", slide_r4.active === true);\n  }\n}\n\nfunction CarouselComponent_ol_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"ol\", 5);\n    ɵngcc0.ɵɵtemplate(1, CarouselComponent_ol_1_li_1_Template, 1, 2, \"li\", 6);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngForOf\", ctx_r0.indicatorsSlides());\n  }\n}\n\nfunction CarouselComponent_a_4_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"span\", 11);\n    ɵngcc0.ɵɵtext(1, \"Previous\");\n    ɵngcc0.ɵɵelementEnd();\n  }\n}\n\nfunction CarouselComponent_a_4_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r10 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"a\", 8);\n    ɵngcc0.ɵɵlistener(\"click\", function CarouselComponent_a_4_Template_a_click_0_listener() {\n      ɵngcc0.ɵɵrestoreView(_r10);\n      const ctx_r9 = ɵngcc0.ɵɵnextContext();\n      return ɵngcc0.ɵɵresetView(ctx_r9.previousSlide());\n    });\n    ɵngcc0.ɵɵelement(1, \"span\", 9);\n    ɵngcc0.ɵɵtemplate(2, CarouselComponent_a_4_span_2_Template, 2, 0, \"span\", 10);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵclassProp(\"disabled\", ctx_r1.activeSlide === 0 && ctx_r1.noWrap);\n    ɵngcc0.ɵɵadvance(2);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r1.isBs4);\n  }\n}\n\nfunction CarouselComponent_a_5_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r12 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"a\", 12);\n    ɵngcc0.ɵɵlistener(\"click\", function CarouselComponent_a_5_Template_a_click_0_listener() {\n      ɵngcc0.ɵɵrestoreView(_r12);\n      const ctx_r11 = ɵngcc0.ɵɵnextContext();\n      return ɵngcc0.ɵɵresetView(ctx_r11.nextSlide());\n    });\n    ɵngcc0.ɵɵelement(1, \"span\", 13);\n    ɵngcc0.ɵɵelementStart(2, \"span\", 11);\n    ɵngcc0.ɵɵtext(3, \"Next\");\n    ɵngcc0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵclassProp(\"disabled\", ctx_r2.isLast(ctx_r2.activeSlide) && ctx_r2.noWrap);\n  }\n}\n\nconst _c0 = function (a0) {\n  return {\n    \"display\": a0\n  };\n};\n\nconst _c1 = [\"*\"];\n\nclass CarouselConfig {\n  constructor() {\n    /* Default interval of auto changing of slides */\n    this.interval = 5000;\n    /* Is loop of auto changing of slides can be paused */\n\n    this.noPause = false;\n    /* Is slides can wrap from the last to the first slide */\n\n    this.noWrap = false;\n    /* Show carousel-indicators */\n\n    this.showIndicators = true;\n    /* Slides can be paused on focus */\n\n    this.pauseOnFocus = false;\n    /* If `true` - carousel indicators indicate slides chunks works ONLY if singleSlideOffset = FALSE */\n\n    this.indicatorsByChunk = false;\n    /* If value more then 1 — carousel works in multilist mode */\n\n    this.itemsPerSlide = 1;\n    /* If `true` — carousel shifts by one element. By default carousel shifts by number\n        of visible elements (itemsPerSlide field) */\n\n    this.singleSlideOffset = false;\n  }\n\n}\n\nCarouselConfig.ɵfac = function CarouselConfig_Factory(t) {\n  return new (t || CarouselConfig)();\n};\n/** @nocollapse */\n\n\nCarouselConfig.ɵprov = ɵɵdefineInjectable({\n  factory: function CarouselConfig_Factory() {\n    return new CarouselConfig();\n  },\n  token: CarouselConfig,\n  providedIn: \"root\"\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CarouselConfig, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [];\n  }, null);\n})();\n\nif (false) {\n  /** @type {?} */\n  CarouselConfig.prototype.interval;\n  /** @type {?} */\n\n  CarouselConfig.prototype.noPause;\n  /** @type {?} */\n\n  CarouselConfig.prototype.noWrap;\n  /** @type {?} */\n\n  CarouselConfig.prototype.showIndicators;\n  /** @type {?} */\n\n  CarouselConfig.prototype.pauseOnFocus;\n  /** @type {?} */\n\n  CarouselConfig.prototype.indicatorsByChunk;\n  /** @type {?} */\n\n  CarouselConfig.prototype.itemsPerSlide;\n  /** @type {?} */\n\n  CarouselConfig.prototype.singleSlideOffset;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Returns the index of the last element in the array where predicate is true, and -1\n * otherwise.\n * @template T\n * @param {?} array The source array to search in\n * @param {?} predicate find calls predicate once for each element of the array, in descending\n * order, until it finds one where predicate returns true. If such an element is found,\n * findLastIndex immediately returns that element index. Otherwise, findLastIndex returns -1.\n * @return {?}\n */\n\n\nfunction findLastIndex(array, predicate) {\n  /** @type {?} */\n  let l = array.length;\n\n  while (l--) {\n    if (predicate(array[l], l, array)) {\n      return l;\n    }\n  }\n\n  return -1;\n}\n/**\n * @template T\n * @param {?} array\n * @param {?} size\n * @return {?}\n */\n\n\nfunction chunkByNumber(array, size) {\n  /** @type {?} */\n  const out = [];\n  /** @type {?} */\n\n  const n = Math.ceil(array.length / size);\n  /** @type {?} */\n\n  let i = 0;\n\n  while (i < n) {\n    /** @type {?} */\n    const chunk = array.splice(0, i === n - 1 && size < array.length ? array.length : size);\n    out.push(chunk);\n    i++;\n  }\n\n  return out;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @enum {number} */\n\n\nconst Direction = {\n  UNKNOWN: 0,\n  NEXT: 1,\n  PREV: 2\n};\nDirection[Direction.UNKNOWN] = 'UNKNOWN';\nDirection[Direction.NEXT] = 'NEXT';\nDirection[Direction.PREV] = 'PREV';\n/**\n * Base element to create carousel\n */\n\nclass CarouselComponent {\n  /**\n   * @param {?} config\n   * @param {?} ngZone\n   */\n  constructor(config, ngZone) {\n    this.ngZone = ngZone;\n    /* If `true` - carousel indicators indicate slides chunks\n         works ONLY if singleSlideOffset = FALSE */\n\n    this.indicatorsByChunk = false;\n    /* If value more then 1 — carousel works in multilist mode */\n\n    this.itemsPerSlide = 1;\n    /* If `true` — carousel shifts by one element. By default carousel shifts by number\n         of visible elements (itemsPerSlide field) */\n\n    this.singleSlideOffset = false;\n    /**\n     * Turn on/off animation. Animation doesn't work for multilist carousel\n     */\n\n    this.isAnimated = false;\n    /**\n     * Will be emitted when active slide has been changed. Part of two-way-bindable [(activeSlide)] property\n     */\n\n    this.activeSlideChange = new EventEmitter(false);\n    /**\n     * Will be emitted when active slides has been changed in multilist mode\n     */\n\n    this.slideRangeChange = new EventEmitter();\n    /* Index to start display slides from it */\n\n    this.startFromIndex = 0;\n    this._slides = new LinkedList();\n    this._currentVisibleSlidesIndex = 0;\n    this.destroyed = false;\n\n    this.getActive =\n    /**\n    * @param {?} slide\n    * @return {?}\n    */\n    slide => slide.active;\n\n    this.makeSlidesConsistent =\n    /**\n    * @param {?} slides\n    * @return {?}\n    */\n    slides => {\n      slides.forEach(\n      /**\n      * @param {?} slide\n      * @param {?} index\n      * @return {?}\n      */\n      (slide, index) => slide.item.order = index);\n    };\n\n    Object.assign(this, config);\n  }\n  /**\n   * Index of currently displayed slide(started for 0)\n   * @param {?} index\n   * @return {?}\n   */\n\n\n  set activeSlide(index) {\n    if (this.multilist) {\n      return;\n    }\n\n    if (this._slides.length && index !== this._currentActiveSlide) {\n      this._select(index);\n    }\n  }\n  /**\n   * @return {?}\n   */\n\n\n  get activeSlide() {\n    return this._currentActiveSlide;\n  }\n  /**\n   * Delay of item cycling in milliseconds. If false, carousel won't cycle\n   * automatically.\n   * @return {?}\n   */\n\n\n  get interval() {\n    return this._interval;\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n\n\n  set interval(value) {\n    this._interval = value;\n    this.restartTimer();\n  }\n  /**\n   * @return {?}\n   */\n\n\n  get slides() {\n    return this._slides.toArray();\n  }\n  /**\n   * @return {?}\n   */\n\n\n  get isBs4() {\n    return !isBs3();\n  }\n  /**\n   * @return {?}\n   */\n\n\n  ngAfterViewInit() {\n    setTimeout(\n    /**\n    * @return {?}\n    */\n    () => {\n      if (this.singleSlideOffset) {\n        this.indicatorsByChunk = false;\n      }\n\n      if (this.multilist) {\n        this._chunkedSlides = chunkByNumber(this.mapSlidesAndIndexes(), this.itemsPerSlide);\n        this.selectInitialSlides();\n      }\n    }, 0);\n  }\n  /**\n   * @return {?}\n   */\n\n\n  ngOnDestroy() {\n    this.destroyed = true;\n  }\n  /**\n   * Adds new slide. If this slide is first in collection - set it as active\n   * and starts auto changing\n   * @param {?} slide\n   * @return {?}\n   */\n\n\n  addSlide(slide) {\n    this._slides.add(slide);\n\n    if (this.multilist && this._slides.length <= this.itemsPerSlide) {\n      slide.active = true;\n    }\n\n    if (!this.multilist && this.isAnimated) {\n      slide.isAnimated = true;\n    }\n\n    if (!this.multilist && this._slides.length === 1) {\n      this._currentActiveSlide = undefined;\n      this.activeSlide = 0;\n      this.play();\n    }\n\n    if (this.multilist && this._slides.length > this.itemsPerSlide) {\n      this.play();\n    }\n  }\n  /**\n   * Removes specified slide. If this slide is active - will roll to another\n   * slide\n   * @param {?} slide\n   * @return {?}\n   */\n\n\n  removeSlide(slide) {\n    /** @type {?} */\n    const remIndex = this._slides.indexOf(slide);\n\n    if (this._currentActiveSlide === remIndex) {\n      // removing of active slide\n\n      /** @type {?} */\n      let nextSlideIndex = void 0;\n\n      if (this._slides.length > 1) {\n        // if this slide last - will roll to first slide, if noWrap flag is\n        // FALSE or to previous, if noWrap is TRUE in case, if this slide in\n        // middle of collection, index of next slide is same to removed\n        nextSlideIndex = !this.isLast(remIndex) ? remIndex : this.noWrap ? remIndex - 1 : 0;\n      }\n\n      this._slides.remove(remIndex); // prevents exception with changing some value after checking\n\n\n      setTimeout(\n      /**\n      * @return {?}\n      */\n      () => {\n        this._select(nextSlideIndex);\n      }, 0);\n    } else {\n      this._slides.remove(remIndex);\n      /** @type {?} */\n\n\n      const currentSlideIndex = this.getCurrentSlideIndex();\n      setTimeout(\n      /**\n      * @return {?}\n      */\n      () => {\n        // after removing, need to actualize index of current active slide\n        this._currentActiveSlide = currentSlideIndex;\n        this.activeSlideChange.emit(this._currentActiveSlide);\n      }, 0);\n    }\n  }\n  /**\n   * @param {?=} force\n   * @return {?}\n   */\n\n\n  nextSlideFromInterval(force = false) {\n    this.move(Direction.NEXT, force);\n  }\n  /**\n   * Rolling to next slide\n   * @param {?=} force\n   * @return {?}\n   */\n\n\n  nextSlide(force = false) {\n    if (this.isPlaying) {\n      this.restartTimer();\n    }\n\n    this.move(Direction.NEXT, force);\n  }\n  /**\n   * Rolling to previous slide\n   * @param {?=} force\n   * @return {?}\n   */\n\n\n  previousSlide(force = false) {\n    if (this.isPlaying) {\n      this.restartTimer();\n    }\n\n    this.move(Direction.PREV, force);\n  }\n  /**\n   * @return {?}\n   */\n\n\n  getFirstVisibleIndex() {\n    return this.slides.findIndex(this.getActive);\n  }\n  /**\n   * @return {?}\n   */\n\n\n  getLastVisibleIndex() {\n    return findLastIndex(this.slides, this.getActive);\n  }\n  /**\n   * @param {?} direction\n   * @param {?=} force\n   * @return {?}\n   */\n\n\n  move(direction, force = false) {\n    /** @type {?} */\n    const firstVisibleIndex = this.getFirstVisibleIndex();\n    /** @type {?} */\n\n    const lastVisibleIndex = this.getLastVisibleIndex();\n\n    if (this.noWrap) {\n      if (direction === Direction.NEXT && this.isLast(lastVisibleIndex) || direction === Direction.PREV && firstVisibleIndex === 0) {\n        return;\n      }\n    }\n\n    if (!this.multilist) {\n      this.activeSlide = this.findNextSlideIndex(direction, force);\n    } else {\n      this.moveMultilist(direction);\n    }\n  }\n  /**\n   * Swith slides by enter, space and arrows keys\n   * \\@internal\n   * @param {?} event\n   * @return {?}\n   */\n\n\n  keydownPress(event) {\n    // tslint:disable-next-line:deprecation\n    if (event.keyCode === 13 || event.key === 'Enter' || event.keyCode === 32 || event.key === 'Space') {\n      this.nextSlide();\n      event.preventDefault();\n      return;\n    } // tslint:disable-next-line:deprecation\n\n\n    if (event.keyCode === 37 || event.key === 'LeftArrow') {\n      this.previousSlide();\n      return;\n    } // tslint:disable-next-line:deprecation\n\n\n    if (event.keyCode === 39 || event.key === 'RightArrow') {\n      this.nextSlide();\n      return;\n    }\n  }\n  /**\n   * Play on mouse leave\n   * \\@internal\n   * @return {?}\n   */\n\n\n  onMouseLeave() {\n    if (!this.pauseOnFocus) {\n      this.play();\n    }\n  }\n  /**\n   * Play on mouse up\n   * \\@internal\n   * @return {?}\n   */\n\n\n  onMouseUp() {\n    if (!this.pauseOnFocus) {\n      this.play();\n    }\n  }\n  /**\n   * When slides on focus autoplay is stopped(optional)\n   * \\@internal\n   * @return {?}\n   */\n\n\n  pauseFocusIn() {\n    if (this.pauseOnFocus) {\n      this.isPlaying = false;\n      this.resetTimer();\n    }\n  }\n  /**\n   * When slides out of focus autoplay is started\n   * \\@internal\n   * @return {?}\n   */\n\n\n  pauseFocusOut() {\n    this.play();\n  }\n  /**\n   * Rolling to specified slide\n   * @param {?} index\n   * @return {?}\n   */\n\n\n  selectSlide(index) {\n    if (this.isPlaying) {\n      this.restartTimer();\n    }\n\n    if (!this.multilist) {\n      this.activeSlide = this.indicatorsByChunk ? index * this.itemsPerSlide : index;\n    } else {\n      this.selectSlideRange(this.indicatorsByChunk ? index * this.itemsPerSlide : index);\n    }\n  }\n  /**\n   * Starts a auto changing of slides\n   * @return {?}\n   */\n\n\n  play() {\n    if (!this.isPlaying) {\n      this.isPlaying = true;\n      this.restartTimer();\n    }\n  }\n  /**\n   * Stops a auto changing of slides\n   * @return {?}\n   */\n\n\n  pause() {\n    if (!this.noPause) {\n      this.isPlaying = false;\n      this.resetTimer();\n    }\n  }\n  /**\n   * Finds and returns index of currently displayed slide\n   * @return {?}\n   */\n\n\n  getCurrentSlideIndex() {\n    return this._slides.findIndex(this.getActive);\n  }\n  /**\n   * Defines, whether the specified index is last in collection\n   * @param {?} index\n   * @return {?}\n   */\n\n\n  isLast(index) {\n    return index + 1 >= this._slides.length;\n  }\n  /**\n   * Defines, whether the specified index is first in collection\n   * @param {?} index\n   * @return {?}\n   */\n\n\n  isFirst(index) {\n    return index === 0;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  indicatorsSlides() {\n    return this.slides.filter(\n    /**\n    * @param {?} slide\n    * @param {?} index\n    * @return {?}\n    */\n    (slide, index) => !this.indicatorsByChunk || index % this.itemsPerSlide === 0);\n  }\n  /**\n   * @private\n   * @return {?}\n   */\n\n\n  selectInitialSlides() {\n    /** @type {?} */\n    const startIndex = this.startFromIndex <= this._slides.length ? this.startFromIndex : 0;\n    this.hideSlides();\n\n    if (this.singleSlideOffset) {\n      this._slidesWithIndexes = this.mapSlidesAndIndexes();\n\n      if (this._slides.length - startIndex < this.itemsPerSlide) {\n        /** @type {?} */\n        const slidesToAppend = this._slidesWithIndexes.slice(0, startIndex);\n\n        this._slidesWithIndexes = [...this._slidesWithIndexes, ...slidesToAppend].slice(slidesToAppend.length).slice(0, this.itemsPerSlide);\n      } else {\n        this._slidesWithIndexes = this._slidesWithIndexes.slice(startIndex, startIndex + this.itemsPerSlide);\n      }\n\n      this._slidesWithIndexes.forEach(\n      /**\n      * @param {?} slide\n      * @return {?}\n      */\n      slide => slide.item.active = true);\n\n      this.makeSlidesConsistent(this._slidesWithIndexes);\n    } else {\n      this.selectRangeByNestedIndex(startIndex);\n    }\n\n    this.slideRangeChange.emit(this.getVisibleIndexes());\n  }\n  /**\n   * Defines next slide index, depending of direction\n   * @private\n   * @param {?} direction\n   * @param {?} force\n   * @return {?}\n   */\n\n\n  findNextSlideIndex(direction, force) {\n    /** @type {?} */\n    let nextSlideIndex = 0;\n\n    if (!force && this.isLast(this.activeSlide) && direction !== Direction.PREV && this.noWrap) {\n      return undefined;\n    }\n\n    switch (direction) {\n      case Direction.NEXT:\n        // if this is last slide, not force, looping is disabled\n        // and need to going forward - select current slide, as a next\n        nextSlideIndex = !this.isLast(this._currentActiveSlide) ? this._currentActiveSlide + 1 : !force && this.noWrap ? this._currentActiveSlide : 0;\n        break;\n\n      case Direction.PREV:\n        // if this is first slide, not force, looping is disabled\n        // and need to going backward - select current slide, as a next\n        nextSlideIndex = this._currentActiveSlide > 0 ? this._currentActiveSlide - 1 : !force && this.noWrap ? this._currentActiveSlide : this._slides.length - 1;\n        break;\n\n      default:\n        throw new Error('Unknown direction');\n    }\n\n    return nextSlideIndex;\n  }\n  /**\n   * @private\n   * @return {?}\n   */\n\n\n  mapSlidesAndIndexes() {\n    return this.slides.slice().map(\n    /**\n    * @param {?} slide\n    * @param {?} index\n    * @return {?}\n    */\n    (slide, index) => {\n      return {\n        index,\n        item: slide\n      };\n    });\n  }\n  /**\n   * @private\n   * @param {?} index\n   * @return {?}\n   */\n\n\n  selectSlideRange(index) {\n    if (this.isIndexInRange(index)) {\n      return;\n    }\n\n    this.hideSlides();\n\n    if (!this.singleSlideOffset) {\n      this.selectRangeByNestedIndex(index);\n    } else {\n      /** @type {?} */\n      const startIndex = this.isIndexOnTheEdges(index) ? index : index - this.itemsPerSlide + 1;\n      /** @type {?} */\n\n      const endIndex = this.isIndexOnTheEdges(index) ? index + this.itemsPerSlide : index + 1;\n      this._slidesWithIndexes = this.mapSlidesAndIndexes().slice(startIndex, endIndex);\n      this.makeSlidesConsistent(this._slidesWithIndexes);\n\n      this._slidesWithIndexes.forEach(\n      /**\n      * @param {?} slide\n      * @return {?}\n      */\n      slide => slide.item.active = true);\n    }\n\n    this.slideRangeChange.emit(this.getVisibleIndexes());\n  }\n  /**\n   * @private\n   * @param {?} index\n   * @return {?}\n   */\n\n\n  selectRangeByNestedIndex(index) {\n    /** @type {?} */\n    const selectedRange = this._chunkedSlides.map(\n    /**\n    * @param {?} slidesList\n    * @param {?} i\n    * @return {?}\n    */\n    (slidesList, i) => {\n      return {\n        index: i,\n        list: slidesList\n      };\n    }).find(\n    /**\n    * @param {?} slidesList\n    * @return {?}\n    */\n    slidesList => {\n      return slidesList.list.find(\n      /**\n      * @param {?} slide\n      * @return {?}\n      */\n      slide => slide.index === index) !== undefined;\n    });\n\n    this._currentVisibleSlidesIndex = selectedRange.index;\n\n    this._chunkedSlides[selectedRange.index].forEach(\n    /**\n    * @param {?} slide\n    * @return {?}\n    */\n    slide => {\n      slide.item.active = true;\n    });\n  }\n  /**\n   * @private\n   * @param {?} index\n   * @return {?}\n   */\n\n\n  isIndexOnTheEdges(index) {\n    return index + 1 - this.itemsPerSlide <= 0 || index + this.itemsPerSlide <= this._slides.length;\n  }\n  /**\n   * @private\n   * @param {?} index\n   * @return {?}\n   */\n\n\n  isIndexInRange(index) {\n    if (this.singleSlideOffset) {\n      /** @type {?} */\n      const visibleIndexes = this._slidesWithIndexes.map(\n      /**\n      * @param {?} slide\n      * @return {?}\n      */\n      slide => slide.index);\n\n      return visibleIndexes.indexOf(index) >= 0;\n    }\n\n    return index <= this.getLastVisibleIndex() && index >= this.getFirstVisibleIndex();\n  }\n  /**\n   * @private\n   * @return {?}\n   */\n\n\n  hideSlides() {\n    this.slides.forEach(\n    /**\n    * @param {?} slide\n    * @return {?}\n    */\n    slide => slide.active = false);\n  }\n  /**\n   * @private\n   * @return {?}\n   */\n\n\n  isVisibleSlideListLast() {\n    return this._currentVisibleSlidesIndex === this._chunkedSlides.length - 1;\n  }\n  /**\n   * @private\n   * @return {?}\n   */\n\n\n  isVisibleSlideListFirst() {\n    return this._currentVisibleSlidesIndex === 0;\n  }\n  /**\n   * @private\n   * @param {?} direction\n   * @return {?}\n   */\n\n\n  moveSliderByOneItem(direction) {\n    /** @type {?} */\n    let firstVisibleIndex;\n    /** @type {?} */\n\n    let lastVisibleIndex;\n    /** @type {?} */\n\n    let indexToHide;\n    /** @type {?} */\n\n    let indexToShow;\n\n    if (this.noWrap) {\n      firstVisibleIndex = this.getFirstVisibleIndex();\n      lastVisibleIndex = this.getLastVisibleIndex();\n      indexToHide = direction === Direction.NEXT ? firstVisibleIndex : lastVisibleIndex;\n      indexToShow = direction !== Direction.NEXT ? firstVisibleIndex - 1 : !this.isLast(lastVisibleIndex) ? lastVisibleIndex + 1 : 0;\n      this._slides.get(indexToHide).active = false;\n      this._slides.get(indexToShow).active = true;\n      /** @type {?} */\n\n      const slidesToReorder = this.mapSlidesAndIndexes().filter(\n      /**\n      * @param {?} slide\n      * @return {?}\n      */\n      slide => slide.item.active);\n      this.makeSlidesConsistent(slidesToReorder);\n      this.slideRangeChange.emit(this.getVisibleIndexes());\n    } else {\n      /** @type {?} */\n      let displayedIndex;\n      firstVisibleIndex = this._slidesWithIndexes[0].index;\n      lastVisibleIndex = this._slidesWithIndexes[this._slidesWithIndexes.length - 1].index;\n\n      if (direction === Direction.NEXT) {\n        this._slidesWithIndexes.shift();\n\n        displayedIndex = this.isLast(lastVisibleIndex) ? 0 : lastVisibleIndex + 1;\n\n        this._slidesWithIndexes.push({\n          index: displayedIndex,\n          item: this._slides.get(displayedIndex)\n        });\n      } else {\n        this._slidesWithIndexes.pop();\n\n        displayedIndex = this.isFirst(firstVisibleIndex) ? this._slides.length - 1 : firstVisibleIndex - 1;\n        this._slidesWithIndexes = [{\n          index: displayedIndex,\n          item: this._slides.get(displayedIndex)\n        }, ...this._slidesWithIndexes];\n      }\n\n      this.hideSlides();\n\n      this._slidesWithIndexes.forEach(\n      /**\n      * @param {?} slide\n      * @return {?}\n      */\n      slide => slide.item.active = true);\n\n      this.makeSlidesConsistent(this._slidesWithIndexes);\n      this.slideRangeChange.emit(this._slidesWithIndexes.map(\n      /**\n      * @param {?} slide\n      * @return {?}\n      */\n      slide => slide.index));\n    }\n  }\n  /**\n   * @private\n   * @param {?} direction\n   * @return {?}\n   */\n\n\n  moveMultilist(direction) {\n    if (this.singleSlideOffset) {\n      this.moveSliderByOneItem(direction);\n    } else {\n      this.hideSlides();\n\n      if (this.noWrap) {\n        this._currentVisibleSlidesIndex = direction === Direction.NEXT ? this._currentVisibleSlidesIndex + 1 : this._currentVisibleSlidesIndex - 1;\n      } else {\n        if (direction === Direction.NEXT) {\n          this._currentVisibleSlidesIndex = this.isVisibleSlideListLast() ? 0 : this._currentVisibleSlidesIndex + 1;\n        } else {\n          this._currentVisibleSlidesIndex = this.isVisibleSlideListFirst() ? this._chunkedSlides.length - 1 : this._currentVisibleSlidesIndex - 1;\n        }\n      }\n\n      this._chunkedSlides[this._currentVisibleSlidesIndex].forEach(\n      /**\n      * @param {?} slide\n      * @return {?}\n      */\n      slide => slide.item.active = true);\n\n      this.slideRangeChange.emit(this.getVisibleIndexes());\n    }\n  }\n  /**\n   * @private\n   * @return {?}\n   */\n\n\n  getVisibleIndexes() {\n    if (!this.singleSlideOffset) {\n      return this._chunkedSlides[this._currentVisibleSlidesIndex].map(\n      /**\n      * @param {?} slide\n      * @return {?}\n      */\n      slide => slide.index);\n    } else {\n      return this._slidesWithIndexes.map(\n      /**\n      * @param {?} slide\n      * @return {?}\n      */\n      slide => slide.index);\n    }\n  }\n  /**\n   * Sets a slide, which specified through index, as active\n   * @private\n   * @param {?} index\n   * @return {?}\n   */\n\n\n  _select(index) {\n    if (isNaN(index)) {\n      this.pause();\n      return;\n    }\n\n    if (!this.multilist) {\n      /** @type {?} */\n      const currentSlide = this._slides.get(this._currentActiveSlide);\n\n      if (currentSlide) {\n        currentSlide.active = false;\n      }\n    }\n    /** @type {?} */\n\n\n    const nextSlide = this._slides.get(index);\n\n    if (nextSlide) {\n      this._currentActiveSlide = index;\n      nextSlide.active = true;\n      this.activeSlide = index;\n      this.activeSlideChange.emit(index);\n    }\n  }\n  /**\n   * Starts loop of auto changing of slides\n   * @private\n   * @return {?}\n   */\n\n\n  restartTimer() {\n    this.resetTimer();\n    /** @type {?} */\n\n    const interval = +this.interval;\n\n    if (!isNaN(interval) && interval > 0) {\n      this.currentInterval = this.ngZone.runOutsideAngular(\n      /**\n      * @return {?}\n      */\n      () => {\n        return setInterval(\n        /**\n        * @return {?}\n        */\n        () => {\n          /** @type {?} */\n          const nInterval = +this.interval;\n          this.ngZone.run(\n          /**\n          * @return {?}\n          */\n          () => {\n            if (this.isPlaying && !isNaN(this.interval) && nInterval > 0 && this.slides.length) {\n              this.nextSlideFromInterval();\n            } else {\n              this.pause();\n            }\n          });\n        }, interval);\n      });\n    }\n  }\n  /**\n   * @return {?}\n   */\n\n\n  get multilist() {\n    return this.itemsPerSlide > 1;\n  }\n  /**\n   * Stops loop of auto changing of slides\n   * @private\n   * @return {?}\n   */\n\n\n  resetTimer() {\n    if (this.currentInterval) {\n      clearInterval(this.currentInterval);\n      this.currentInterval = void 0;\n    }\n  }\n\n}\n\nCarouselComponent.ɵfac = function CarouselComponent_Factory(t) {\n  return new (t || CarouselComponent)(ɵngcc0.ɵɵdirectiveInject(CarouselConfig), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n};\n\nCarouselComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n  type: CarouselComponent,\n  selectors: [[\"carousel\"]],\n  inputs: {\n    indicatorsByChunk: \"indicatorsByChunk\",\n    itemsPerSlide: \"itemsPerSlide\",\n    singleSlideOffset: \"singleSlideOffset\",\n    isAnimated: \"isAnimated\",\n    startFromIndex: \"startFromIndex\",\n    activeSlide: \"activeSlide\",\n    interval: \"interval\",\n    noWrap: \"noWrap\",\n    noPause: \"noPause\",\n    showIndicators: \"showIndicators\",\n    pauseOnFocus: \"pauseOnFocus\"\n  },\n  outputs: {\n    activeSlideChange: \"activeSlideChange\",\n    slideRangeChange: \"slideRangeChange\"\n  },\n  ngContentSelectors: _c1,\n  decls: 6,\n  vars: 6,\n  consts: [[\"tabindex\", \"0\", 1, \"carousel\", \"slide\", 3, \"mouseenter\", \"mouseleave\", \"mouseup\", \"keydown\", \"focusin\", \"focusout\"], [\"class\", \"carousel-indicators\", 4, \"ngIf\"], [1, \"carousel-inner\", 3, \"ngStyle\"], [\"class\", \"left carousel-control carousel-control-prev\", \"tabindex\", \"0\", \"role\", \"button\", 3, \"disabled\", \"click\", 4, \"ngIf\"], [\"class\", \"right carousel-control carousel-control-next\", \"tabindex\", \"0\", \"role\", \"button\", 3, \"disabled\", \"click\", 4, \"ngIf\"], [1, \"carousel-indicators\"], [3, \"active\", \"click\", 4, \"ngFor\", \"ngForOf\"], [3, \"click\"], [\"tabindex\", \"0\", \"role\", \"button\", 1, \"left\", \"carousel-control\", \"carousel-control-prev\", 3, \"click\"], [\"aria-hidden\", \"true\", 1, \"icon-prev\", \"carousel-control-prev-icon\"], [\"class\", \"sr-only\", 4, \"ngIf\"], [1, \"sr-only\"], [\"tabindex\", \"0\", \"role\", \"button\", 1, \"right\", \"carousel-control\", \"carousel-control-next\", 3, \"click\"], [\"aria-hidden\", \"true\", 1, \"icon-next\", \"carousel-control-next-icon\"]],\n  template: function CarouselComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵprojectionDef();\n      ɵngcc0.ɵɵelementStart(0, \"div\", 0);\n      ɵngcc0.ɵɵlistener(\"mouseenter\", function CarouselComponent_Template_div_mouseenter_0_listener() {\n        return ctx.pause();\n      })(\"mouseleave\", function CarouselComponent_Template_div_mouseleave_0_listener() {\n        return ctx.onMouseLeave();\n      })(\"mouseup\", function CarouselComponent_Template_div_mouseup_0_listener() {\n        return ctx.onMouseUp();\n      })(\"keydown\", function CarouselComponent_Template_div_keydown_0_listener($event) {\n        return ctx.keydownPress($event);\n      })(\"focusin\", function CarouselComponent_Template_div_focusin_0_listener() {\n        return ctx.pauseFocusIn();\n      })(\"focusout\", function CarouselComponent_Template_div_focusout_0_listener() {\n        return ctx.pauseFocusOut();\n      });\n      ɵngcc0.ɵɵtemplate(1, CarouselComponent_ol_1_Template, 2, 1, \"ol\", 1);\n      ɵngcc0.ɵɵelementStart(2, \"div\", 2);\n      ɵngcc0.ɵɵprojection(3);\n      ɵngcc0.ɵɵelementEnd();\n      ɵngcc0.ɵɵtemplate(4, CarouselComponent_a_4_Template, 3, 3, \"a\", 3);\n      ɵngcc0.ɵɵtemplate(5, CarouselComponent_a_5_Template, 4, 2, \"a\", 4);\n      ɵngcc0.ɵɵelementEnd();\n    }\n\n    if (rf & 2) {\n      ɵngcc0.ɵɵadvance(1);\n      ɵngcc0.ɵɵproperty(\"ngIf\", ctx.showIndicators && ctx.slides.length > 1);\n      ɵngcc0.ɵɵadvance(1);\n      ɵngcc0.ɵɵproperty(\"ngStyle\", ɵngcc0.ɵɵpureFunction1(4, _c0, ctx.multilist ? \"flex\" : \"block\"));\n      ɵngcc0.ɵɵadvance(2);\n      ɵngcc0.ɵɵproperty(\"ngIf\", ctx.slides.length > 1);\n      ɵngcc0.ɵɵadvance(1);\n      ɵngcc0.ɵɵproperty(\"ngIf\", ctx.slides.length > 1);\n    }\n  },\n  dependencies: [ɵngcc1.NgForOf, ɵngcc1.NgIf, ɵngcc1.NgStyle],\n  encapsulation: 2\n});\n/** @nocollapse */\n\nCarouselComponent.ctorParameters = () => [{\n  type: CarouselConfig\n}, {\n  type: NgZone\n}];\n\nCarouselComponent.propDecorators = {\n  noWrap: [{\n    type: Input\n  }],\n  noPause: [{\n    type: Input\n  }],\n  showIndicators: [{\n    type: Input\n  }],\n  pauseOnFocus: [{\n    type: Input\n  }],\n  indicatorsByChunk: [{\n    type: Input\n  }],\n  itemsPerSlide: [{\n    type: Input\n  }],\n  singleSlideOffset: [{\n    type: Input\n  }],\n  isAnimated: [{\n    type: Input\n  }],\n  activeSlideChange: [{\n    type: Output\n  }],\n  slideRangeChange: [{\n    type: Output\n  }],\n  activeSlide: [{\n    type: Input\n  }],\n  startFromIndex: [{\n    type: Input\n  }],\n  interval: [{\n    type: Input\n  }]\n};\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CarouselComponent, [{\n    type: Component,\n    args: [{\n      selector: 'carousel',\n      template: \"<div (mouseenter)=\\\"pause()\\\"\\n     (mouseleave)=\\\"onMouseLeave()\\\"\\n     (mouseup)=\\\"onMouseUp()\\\"\\n     (keydown)=\\\"keydownPress($event)\\\"\\n     (focusin)=\\\"pauseFocusIn()\\\"\\n     (focusout)=\\\"pauseFocusOut()\\\"\\n     class=\\\"carousel slide\\\" tabindex=\\\"0\\\">\\n  <ol class=\\\"carousel-indicators\\\" *ngIf=\\\"showIndicators && slides.length > 1\\\">\\n    <li *ngFor=\\\"let slide of indicatorsSlides(); let i = index;\\\"\\n        [class.active]=\\\"slide.active === true\\\"\\n        (click)=\\\"selectSlide(i)\\\">\\n    </li>\\n  </ol>\\n  <div class=\\\"carousel-inner\\\" [ngStyle]=\\\"{'display': multilist ? 'flex' : 'block'}\\\">\\n    <ng-content></ng-content>\\n  </div>\\n  <a class=\\\"left carousel-control carousel-control-prev\\\"\\n     [class.disabled]=\\\"activeSlide === 0 && noWrap\\\"\\n     (click)=\\\"previousSlide()\\\" *ngIf=\\\"slides.length > 1\\\"\\n      tabindex=\\\"0\\\" role=\\\"button\\\">\\n    <span class=\\\"icon-prev carousel-control-prev-icon\\\" aria-hidden=\\\"true\\\"></span>\\n    <span *ngIf=\\\"isBs4\\\" class=\\\"sr-only\\\">Previous</span>\\n  </a>\\n  <a class=\\\"right carousel-control carousel-control-next\\\"\\n     [class.disabled]=\\\"isLast(activeSlide) && noWrap\\\"\\n     (click)=\\\"nextSlide()\\\" *ngIf=\\\"slides.length > 1\\\"\\n     tabindex=\\\"0\\\" role=\\\"button\\\">\\n    <span class=\\\"icon-next carousel-control-next-icon\\\" aria-hidden=\\\"true\\\"></span>\\n    <span class=\\\"sr-only\\\">Next</span>\\n  </a>\\n</div>\\n\"\n    }]\n  }], function () {\n    return [{\n      type: CarouselConfig\n    }, {\n      type: ɵngcc0.NgZone\n    }];\n  }, {\n    indicatorsByChunk: [{\n      type: Input\n    }],\n    itemsPerSlide: [{\n      type: Input\n    }],\n    singleSlideOffset: [{\n      type: Input\n    }],\n    isAnimated: [{\n      type: Input\n    }],\n    activeSlideChange: [{\n      type: Output\n    }],\n    slideRangeChange: [{\n      type: Output\n    }],\n    startFromIndex: [{\n      type: Input\n    }],\n    activeSlide: [{\n      type: Input\n    }],\n    interval: [{\n      type: Input\n    }],\n    noWrap: [{\n      type: Input\n    }],\n    noPause: [{\n      type: Input\n    }],\n    showIndicators: [{\n      type: Input\n    }],\n    pauseOnFocus: [{\n      type: Input\n    }]\n  });\n})();\n\nif (false) {\n  /** @type {?} */\n  CarouselComponent.prototype.noWrap;\n  /** @type {?} */\n\n  CarouselComponent.prototype.noPause;\n  /** @type {?} */\n\n  CarouselComponent.prototype.showIndicators;\n  /** @type {?} */\n\n  CarouselComponent.prototype.pauseOnFocus;\n  /** @type {?} */\n\n  CarouselComponent.prototype.indicatorsByChunk;\n  /** @type {?} */\n\n  CarouselComponent.prototype.itemsPerSlide;\n  /** @type {?} */\n\n  CarouselComponent.prototype.singleSlideOffset;\n  /**\n   * Turn on/off animation. Animation doesn't work for multilist carousel\n   * @type {?}\n   */\n\n  CarouselComponent.prototype.isAnimated;\n  /**\n   * Will be emitted when active slide has been changed. Part of two-way-bindable [(activeSlide)] property\n   * @type {?}\n   */\n\n  CarouselComponent.prototype.activeSlideChange;\n  /**\n   * Will be emitted when active slides has been changed in multilist mode\n   * @type {?}\n   */\n\n  CarouselComponent.prototype.slideRangeChange;\n  /** @type {?} */\n\n  CarouselComponent.prototype.startFromIndex;\n  /**\n   * @type {?}\n   * @protected\n   */\n\n  CarouselComponent.prototype.currentInterval;\n  /**\n   * @type {?}\n   * @protected\n   */\n\n  CarouselComponent.prototype._currentActiveSlide;\n  /**\n   * @type {?}\n   * @protected\n   */\n\n  CarouselComponent.prototype._interval;\n  /**\n   * @type {?}\n   * @protected\n   */\n\n  CarouselComponent.prototype._slides;\n  /**\n   * @type {?}\n   * @protected\n   */\n\n  CarouselComponent.prototype._chunkedSlides;\n  /**\n   * @type {?}\n   * @protected\n   */\n\n  CarouselComponent.prototype._slidesWithIndexes;\n  /**\n   * @type {?}\n   * @protected\n   */\n\n  CarouselComponent.prototype._currentVisibleSlidesIndex;\n  /**\n   * @type {?}\n   * @protected\n   */\n\n  CarouselComponent.prototype.isPlaying;\n  /**\n   * @type {?}\n   * @protected\n   */\n\n  CarouselComponent.prototype.destroyed;\n  /** @type {?} */\n\n  CarouselComponent.prototype.getActive;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  CarouselComponent.prototype.makeSlidesConsistent;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  CarouselComponent.prototype.ngZone;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nclass SlideComponent {\n  /**\n   * @param {?} carousel\n   */\n  constructor(carousel) {\n    this.itemWidth = '100%';\n    this.order = 0;\n    /**\n     * Wraps element by appropriate CSS classes\n     */\n\n    this.addClass = true;\n    this.carousel = carousel;\n  }\n  /**\n   * Fires changes in container collection after adding a new slide instance\n   * @return {?}\n   */\n\n\n  ngOnInit() {\n    this.carousel.addSlide(this);\n    this.itemWidth = `${100 / this.carousel.itemsPerSlide}%`;\n  }\n  /**\n   * Fires changes in container collection after removing of this slide instance\n   * @return {?}\n   */\n\n\n  ngOnDestroy() {\n    this.carousel.removeSlide(this);\n  }\n\n}\n\nSlideComponent.ɵfac = function SlideComponent_Factory(t) {\n  return new (t || SlideComponent)(ɵngcc0.ɵɵdirectiveInject(CarouselComponent));\n};\n\nSlideComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n  type: SlideComponent,\n  selectors: [[\"slide\"]],\n  hostVars: 13,\n  hostBindings: function SlideComponent_HostBindings(rf, ctx) {\n    if (rf & 2) {\n      ɵngcc0.ɵɵattribute(\"aria-hidden\", !ctx.active);\n      ɵngcc0.ɵɵstyleProp(\"width\", ctx.itemWidth)(\"order\", ctx.order);\n      ɵngcc0.ɵɵclassProp(\"item\", ctx.addClass)(\"carousel-item\", ctx.addClass)(\"active\", ctx.active)(\"carousel-animation\", ctx.isAnimated);\n    }\n  },\n  inputs: {\n    active: \"active\"\n  },\n  ngContentSelectors: _c1,\n  decls: 2,\n  vars: 2,\n  consts: [[1, \"item\"]],\n  template: function SlideComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵprojectionDef();\n      ɵngcc0.ɵɵelementStart(0, \"div\", 0);\n      ɵngcc0.ɵɵprojection(1);\n      ɵngcc0.ɵɵelementEnd();\n    }\n\n    if (rf & 2) {\n      ɵngcc0.ɵɵclassProp(\"active\", ctx.active);\n    }\n  },\n  styles: [\".carousel-animation[_nghost-%COMP%] {\\n       transition: opacity 0.6s ease, visibility 0.6s ease;\\n       float: left;\\n    }\\n    .carousel-animation.active[_nghost-%COMP%] {\\n      opacity: 1;\\n      visibility: visible;\\n    }\\n    .carousel-animation[_nghost-%COMP%]:not(.active) {\\n      display: block;\\n      position: absolute;\\n      opacity: 0;\\n      visibility: hidden;\\n    }\"]\n});\n/** @nocollapse */\n\nSlideComponent.ctorParameters = () => [{\n  type: CarouselComponent\n}];\n\nSlideComponent.propDecorators = {\n  active: [{\n    type: HostBinding,\n    args: ['class.active']\n  }, {\n    type: Input\n  }],\n  itemWidth: [{\n    type: HostBinding,\n    args: ['style.width']\n  }],\n  order: [{\n    type: HostBinding,\n    args: ['style.order']\n  }],\n  isAnimated: [{\n    type: HostBinding,\n    args: ['class.carousel-animation']\n  }],\n  addClass: [{\n    type: HostBinding,\n    args: ['class.item']\n  }, {\n    type: HostBinding,\n    args: ['class.carousel-item']\n  }]\n};\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SlideComponent, [{\n    type: Component,\n    args: [{\n      selector: 'slide',\n      template: `\n    <div [class.active]=\"active\" class=\"item\">\n      <ng-content></ng-content>\n    </div>\n  `,\n      host: {\n        '[attr.aria-hidden]': '!active'\n      },\n      styles: [\"\\n    :host.carousel-animation {\\n       transition: opacity 0.6s ease, visibility 0.6s ease;\\n       float: left;\\n    }\\n    :host.carousel-animation.active {\\n      opacity: 1;\\n      visibility: visible;\\n    }\\n    :host.carousel-animation:not(.active) {\\n      display: block;\\n      position: absolute;\\n      opacity: 0;\\n      visibility: hidden;\\n    }\\n  \"]\n    }]\n  }], function () {\n    return [{\n      type: CarouselComponent\n    }];\n  }, {\n    itemWidth: [{\n      type: HostBinding,\n      args: ['style.width']\n    }],\n    order: [{\n      type: HostBinding,\n      args: ['style.order']\n    }],\n    addClass: [{\n      type: HostBinding,\n      args: ['class.item']\n    }, {\n      type: HostBinding,\n      args: ['class.carousel-item']\n    }],\n    active: [{\n      type: HostBinding,\n      args: ['class.active']\n    }, {\n      type: Input\n    }],\n    isAnimated: [{\n      type: HostBinding,\n      args: ['class.carousel-animation']\n    }]\n  });\n})();\n\nif (false) {\n  /**\n   * Is current slide active\n   * @type {?}\n   */\n  SlideComponent.prototype.active;\n  /** @type {?} */\n\n  SlideComponent.prototype.itemWidth;\n  /** @type {?} */\n\n  SlideComponent.prototype.order;\n  /** @type {?} */\n\n  SlideComponent.prototype.isAnimated;\n  /**\n   * Wraps element by appropriate CSS classes\n   * @type {?}\n   */\n\n  SlideComponent.prototype.addClass;\n  /**\n   * Link to Parent(container-collection) component\n   * @type {?}\n   * @protected\n   */\n\n  SlideComponent.prototype.carousel;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nclass CarouselModule {\n  /**\n   * @return {?}\n   */\n  static forRoot() {\n    return {\n      ngModule: CarouselModule,\n      providers: []\n    };\n  }\n\n}\n\nCarouselModule.ɵfac = function CarouselModule_Factory(t) {\n  return new (t || CarouselModule)();\n};\n\nCarouselModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n  type: CarouselModule\n});\nCarouselModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n  imports: [CommonModule]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CarouselModule, [{\n    type: NgModule,\n    args: [{\n      imports: [CommonModule],\n      declarations: [SlideComponent, CarouselComponent],\n      exports: [SlideComponent, CarouselComponent]\n    }]\n  }], null, null);\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(CarouselModule, {\n    declarations: function () {\n      return [SlideComponent, CarouselComponent];\n    },\n    imports: function () {\n      return [CommonModule];\n    },\n    exports: function () {\n      return [SlideComponent, CarouselComponent];\n    }\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nexport { CarouselComponent, CarouselConfig, CarouselModule, SlideComponent };","map":{"version":3,"names":["Injectable","ɵɵdefineInjectable","EventEmitter","Component","NgZone","Input","Output","HostBinding","NgModule","LinkedList","isBs3","CommonModule","ɵngcc0","ɵngcc1","CarouselComponent_ol_1_li_1_Template","rf","ctx","_r7","ɵɵgetCurrentView","ɵɵelementStart","ɵɵlistener","CarouselComponent_ol_1_li_1_Template_li_click_0_listener","restoredCtx","ɵɵrestoreView","i_r5","index","ctx_r6","ɵɵnextContext","ɵɵresetView","selectSlide","ɵɵelementEnd","slide_r4","$implicit","ɵɵclassProp","active","CarouselComponent_ol_1_Template","ɵɵtemplate","ctx_r0","ɵɵadvance","ɵɵproperty","indicatorsSlides","CarouselComponent_a_4_span_2_Template","ɵɵtext","CarouselComponent_a_4_Template","_r10","CarouselComponent_a_4_Template_a_click_0_listener","ctx_r9","previousSlide","ɵɵelement","ctx_r1","activeSlide","noWrap","isBs4","CarouselComponent_a_5_Template","_r12","CarouselComponent_a_5_Template_a_click_0_listener","ctx_r11","nextSlide","ctx_r2","isLast","_c0","a0","_c1","CarouselConfig","constructor","interval","noPause","showIndicators","pauseOnFocus","indicatorsByChunk","itemsPerSlide","singleSlideOffset","ɵfac","CarouselConfig_Factory","t","ɵprov","factory","token","providedIn","ngDevMode","ɵsetClassMetadata","type","args","prototype","findLastIndex","array","predicate","l","length","chunkByNumber","size","out","n","Math","ceil","i","chunk","splice","push","Direction","UNKNOWN","NEXT","PREV","CarouselComponent","config","ngZone","isAnimated","activeSlideChange","slideRangeChange","startFromIndex","_slides","_currentVisibleSlidesIndex","destroyed","getActive","slide","makeSlidesConsistent","slides","forEach","item","order","Object","assign","multilist","_currentActiveSlide","_select","_interval","value","restartTimer","toArray","ngAfterViewInit","setTimeout","_chunkedSlides","mapSlidesAndIndexes","selectInitialSlides","ngOnDestroy","addSlide","add","undefined","play","removeSlide","remIndex","indexOf","nextSlideIndex","remove","currentSlideIndex","getCurrentSlideIndex","emit","nextSlideFromInterval","force","move","isPlaying","getFirstVisibleIndex","findIndex","getLastVisibleIndex","direction","firstVisibleIndex","lastVisibleIndex","findNextSlideIndex","moveMultilist","keydownPress","event","keyCode","key","preventDefault","onMouseLeave","onMouseUp","pauseFocusIn","resetTimer","pauseFocusOut","selectSlideRange","pause","isFirst","filter","startIndex","hideSlides","_slidesWithIndexes","slidesToAppend","slice","selectRangeByNestedIndex","getVisibleIndexes","Error","map","isIndexInRange","isIndexOnTheEdges","endIndex","selectedRange","slidesList","list","find","visibleIndexes","isVisibleSlideListLast","isVisibleSlideListFirst","moveSliderByOneItem","indexToHide","indexToShow","get","slidesToReorder","displayedIndex","shift","pop","isNaN","currentSlide","currentInterval","runOutsideAngular","setInterval","nInterval","run","clearInterval","CarouselComponent_Factory","ɵɵdirectiveInject","ɵcmp","ɵɵdefineComponent","selectors","inputs","outputs","ngContentSelectors","decls","vars","consts","template","CarouselComponent_Template","ɵɵprojectionDef","CarouselComponent_Template_div_mouseenter_0_listener","CarouselComponent_Template_div_mouseleave_0_listener","CarouselComponent_Template_div_mouseup_0_listener","CarouselComponent_Template_div_keydown_0_listener","$event","CarouselComponent_Template_div_focusin_0_listener","CarouselComponent_Template_div_focusout_0_listener","ɵɵprojection","ɵɵpureFunction1","dependencies","NgForOf","NgIf","NgStyle","encapsulation","ctorParameters","propDecorators","selector","SlideComponent","carousel","itemWidth","addClass","ngOnInit","SlideComponent_Factory","hostVars","hostBindings","SlideComponent_HostBindings","ɵɵattribute","ɵɵstyleProp","SlideComponent_Template","styles","host","CarouselModule","forRoot","ngModule","providers","CarouselModule_Factory","ɵmod","ɵɵdefineNgModule","ɵinj","ɵɵdefineInjector","imports","declarations","exports","ngJitMode","ɵɵsetNgModuleScope"],"sources":["C:/Users/espli/OneDrive/Desktop/BlogLab/BlogLab-UI/node_modules/ngx-bootstrap/__ivy_ngcc__/carousel/fesm2015/ngx-bootstrap-carousel.js"],"sourcesContent":["import { Injectable, ɵɵdefineInjectable, EventEmitter, Component, NgZone, Input, Output, HostBinding, NgModule } from '@angular/core';\nimport { LinkedList, isBs3 } from 'ngx-bootstrap/utils';\nimport { CommonModule } from '@angular/common';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/common';\n\nfunction CarouselComponent_ol_1_li_1_Template(rf, ctx) { if (rf & 1) {\n    const _r7 = ɵngcc0.ɵɵgetCurrentView();\n    ɵngcc0.ɵɵelementStart(0, \"li\", 7);\n    ɵngcc0.ɵɵlistener(\"click\", function CarouselComponent_ol_1_li_1_Template_li_click_0_listener() { const restoredCtx = ɵngcc0.ɵɵrestoreView(_r7); const i_r5 = restoredCtx.index; const ctx_r6 = ɵngcc0.ɵɵnextContext(2); return ɵngcc0.ɵɵresetView(ctx_r6.selectSlide(i_r5)); });\n    ɵngcc0.ɵɵelementEnd();\n} if (rf & 2) {\n    const slide_r4 = ctx.$implicit;\n    ɵngcc0.ɵɵclassProp(\"active\", slide_r4.active === true);\n} }\nfunction CarouselComponent_ol_1_Template(rf, ctx) { if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"ol\", 5);\n    ɵngcc0.ɵɵtemplate(1, CarouselComponent_ol_1_li_1_Template, 1, 2, \"li\", 6);\n    ɵngcc0.ɵɵelementEnd();\n} if (rf & 2) {\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngForOf\", ctx_r0.indicatorsSlides());\n} }\nfunction CarouselComponent_a_4_span_2_Template(rf, ctx) { if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"span\", 11);\n    ɵngcc0.ɵɵtext(1, \"Previous\");\n    ɵngcc0.ɵɵelementEnd();\n} }\nfunction CarouselComponent_a_4_Template(rf, ctx) { if (rf & 1) {\n    const _r10 = ɵngcc0.ɵɵgetCurrentView();\n    ɵngcc0.ɵɵelementStart(0, \"a\", 8);\n    ɵngcc0.ɵɵlistener(\"click\", function CarouselComponent_a_4_Template_a_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r10); const ctx_r9 = ɵngcc0.ɵɵnextContext(); return ɵngcc0.ɵɵresetView(ctx_r9.previousSlide()); });\n    ɵngcc0.ɵɵelement(1, \"span\", 9);\n    ɵngcc0.ɵɵtemplate(2, CarouselComponent_a_4_span_2_Template, 2, 0, \"span\", 10);\n    ɵngcc0.ɵɵelementEnd();\n} if (rf & 2) {\n    const ctx_r1 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵclassProp(\"disabled\", ctx_r1.activeSlide === 0 && ctx_r1.noWrap);\n    ɵngcc0.ɵɵadvance(2);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r1.isBs4);\n} }\nfunction CarouselComponent_a_5_Template(rf, ctx) { if (rf & 1) {\n    const _r12 = ɵngcc0.ɵɵgetCurrentView();\n    ɵngcc0.ɵɵelementStart(0, \"a\", 12);\n    ɵngcc0.ɵɵlistener(\"click\", function CarouselComponent_a_5_Template_a_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r12); const ctx_r11 = ɵngcc0.ɵɵnextContext(); return ɵngcc0.ɵɵresetView(ctx_r11.nextSlide()); });\n    ɵngcc0.ɵɵelement(1, \"span\", 13);\n    ɵngcc0.ɵɵelementStart(2, \"span\", 11);\n    ɵngcc0.ɵɵtext(3, \"Next\");\n    ɵngcc0.ɵɵelementEnd()();\n} if (rf & 2) {\n    const ctx_r2 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵclassProp(\"disabled\", ctx_r2.isLast(ctx_r2.activeSlide) && ctx_r2.noWrap);\n} }\nconst _c0 = function (a0) { return { \"display\": a0 }; };\nconst _c1 = [\"*\"];\nclass CarouselConfig {\n    constructor() {\n        /* Default interval of auto changing of slides */\n        this.interval = 5000;\n        /* Is loop of auto changing of slides can be paused */\n        this.noPause = false;\n        /* Is slides can wrap from the last to the first slide */\n        this.noWrap = false;\n        /* Show carousel-indicators */\n        this.showIndicators = true;\n        /* Slides can be paused on focus */\n        this.pauseOnFocus = false;\n        /* If `true` - carousel indicators indicate slides chunks works ONLY if singleSlideOffset = FALSE */\n        this.indicatorsByChunk = false;\n        /* If value more then 1 — carousel works in multilist mode */\n        this.itemsPerSlide = 1;\n        /* If `true` — carousel shifts by one element. By default carousel shifts by number\n            of visible elements (itemsPerSlide field) */\n        this.singleSlideOffset = false;\n    }\n}\nCarouselConfig.ɵfac = function CarouselConfig_Factory(t) { return new (t || CarouselConfig)(); };\n/** @nocollapse */ CarouselConfig.ɵprov = ɵɵdefineInjectable({ factory: function CarouselConfig_Factory() { return new CarouselConfig(); }, token: CarouselConfig, providedIn: \"root\" });\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CarouselConfig, [{\n        type: Injectable,\n        args: [{\n                providedIn: 'root'\n            }]\n    }], function () { return []; }, null); })();\nif (false) {\n    /** @type {?} */\n    CarouselConfig.prototype.interval;\n    /** @type {?} */\n    CarouselConfig.prototype.noPause;\n    /** @type {?} */\n    CarouselConfig.prototype.noWrap;\n    /** @type {?} */\n    CarouselConfig.prototype.showIndicators;\n    /** @type {?} */\n    CarouselConfig.prototype.pauseOnFocus;\n    /** @type {?} */\n    CarouselConfig.prototype.indicatorsByChunk;\n    /** @type {?} */\n    CarouselConfig.prototype.itemsPerSlide;\n    /** @type {?} */\n    CarouselConfig.prototype.singleSlideOffset;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Returns the index of the last element in the array where predicate is true, and -1\n * otherwise.\n * @template T\n * @param {?} array The source array to search in\n * @param {?} predicate find calls predicate once for each element of the array, in descending\n * order, until it finds one where predicate returns true. If such an element is found,\n * findLastIndex immediately returns that element index. Otherwise, findLastIndex returns -1.\n * @return {?}\n */\nfunction findLastIndex(array, predicate) {\n    /** @type {?} */\n    let l = array.length;\n    while (l--) {\n        if (predicate(array[l], l, array)) {\n            return l;\n        }\n    }\n    return -1;\n}\n/**\n * @template T\n * @param {?} array\n * @param {?} size\n * @return {?}\n */\nfunction chunkByNumber(array, size) {\n    /** @type {?} */\n    const out = [];\n    /** @type {?} */\n    const n = Math.ceil((array.length) / size);\n    /** @type {?} */\n    let i = 0;\n    while (i < n) {\n        /** @type {?} */\n        const chunk = array.splice(0, (i === n - 1) && size < array.length ? array.length : size);\n        out.push(chunk);\n        i++;\n    }\n    return out;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @enum {number} */\nconst Direction = {\n    UNKNOWN: 0,\n    NEXT: 1,\n    PREV: 2,\n};\nDirection[Direction.UNKNOWN] = 'UNKNOWN';\nDirection[Direction.NEXT] = 'NEXT';\nDirection[Direction.PREV] = 'PREV';\n/**\n * Base element to create carousel\n */\nclass CarouselComponent {\n    /**\n     * @param {?} config\n     * @param {?} ngZone\n     */\n    constructor(config, ngZone) {\n        this.ngZone = ngZone;\n        /* If `true` - carousel indicators indicate slides chunks\n             works ONLY if singleSlideOffset = FALSE */\n        this.indicatorsByChunk = false;\n        /* If value more then 1 — carousel works in multilist mode */\n        this.itemsPerSlide = 1;\n        /* If `true` — carousel shifts by one element. By default carousel shifts by number\n             of visible elements (itemsPerSlide field) */\n        this.singleSlideOffset = false;\n        /**\n         * Turn on/off animation. Animation doesn't work for multilist carousel\n         */\n        this.isAnimated = false;\n        /**\n         * Will be emitted when active slide has been changed. Part of two-way-bindable [(activeSlide)] property\n         */\n        this.activeSlideChange = new EventEmitter(false);\n        /**\n         * Will be emitted when active slides has been changed in multilist mode\n         */\n        this.slideRangeChange = new EventEmitter();\n        /* Index to start display slides from it */\n        this.startFromIndex = 0;\n        this._slides = new LinkedList();\n        this._currentVisibleSlidesIndex = 0;\n        this.destroyed = false;\n        this.getActive = (/**\n         * @param {?} slide\n         * @return {?}\n         */\n        (slide) => slide.active);\n        this.makeSlidesConsistent = (/**\n         * @param {?} slides\n         * @return {?}\n         */\n        (slides) => {\n            slides.forEach((/**\n             * @param {?} slide\n             * @param {?} index\n             * @return {?}\n             */\n            (slide, index) => slide.item.order = index));\n        });\n        Object.assign(this, config);\n    }\n    /**\n     * Index of currently displayed slide(started for 0)\n     * @param {?} index\n     * @return {?}\n     */\n    set activeSlide(index) {\n        if (this.multilist) {\n            return;\n        }\n        if (this._slides.length && index !== this._currentActiveSlide) {\n            this._select(index);\n        }\n    }\n    /**\n     * @return {?}\n     */\n    get activeSlide() {\n        return this._currentActiveSlide;\n    }\n    /**\n     * Delay of item cycling in milliseconds. If false, carousel won't cycle\n     * automatically.\n     * @return {?}\n     */\n    get interval() {\n        return this._interval;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set interval(value) {\n        this._interval = value;\n        this.restartTimer();\n    }\n    /**\n     * @return {?}\n     */\n    get slides() {\n        return this._slides.toArray();\n    }\n    /**\n     * @return {?}\n     */\n    get isBs4() {\n        return !isBs3();\n    }\n    /**\n     * @return {?}\n     */\n    ngAfterViewInit() {\n        setTimeout((/**\n         * @return {?}\n         */\n        () => {\n            if (this.singleSlideOffset) {\n                this.indicatorsByChunk = false;\n            }\n            if (this.multilist) {\n                this._chunkedSlides = chunkByNumber(this.mapSlidesAndIndexes(), this.itemsPerSlide);\n                this.selectInitialSlides();\n            }\n        }), 0);\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this.destroyed = true;\n    }\n    /**\n     * Adds new slide. If this slide is first in collection - set it as active\n     * and starts auto changing\n     * @param {?} slide\n     * @return {?}\n     */\n    addSlide(slide) {\n        this._slides.add(slide);\n        if (this.multilist && this._slides.length <= this.itemsPerSlide) {\n            slide.active = true;\n        }\n        if (!this.multilist && this.isAnimated) {\n            slide.isAnimated = true;\n        }\n        if (!this.multilist && this._slides.length === 1) {\n            this._currentActiveSlide = undefined;\n            this.activeSlide = 0;\n            this.play();\n        }\n        if (this.multilist && this._slides.length > this.itemsPerSlide) {\n            this.play();\n        }\n    }\n    /**\n     * Removes specified slide. If this slide is active - will roll to another\n     * slide\n     * @param {?} slide\n     * @return {?}\n     */\n    removeSlide(slide) {\n        /** @type {?} */\n        const remIndex = this._slides.indexOf(slide);\n        if (this._currentActiveSlide === remIndex) {\n            // removing of active slide\n            /** @type {?} */\n            let nextSlideIndex = void 0;\n            if (this._slides.length > 1) {\n                // if this slide last - will roll to first slide, if noWrap flag is\n                // FALSE or to previous, if noWrap is TRUE in case, if this slide in\n                // middle of collection, index of next slide is same to removed\n                nextSlideIndex = !this.isLast(remIndex)\n                    ? remIndex\n                    : this.noWrap ? remIndex - 1 : 0;\n            }\n            this._slides.remove(remIndex);\n            // prevents exception with changing some value after checking\n            setTimeout((/**\n             * @return {?}\n             */\n            () => {\n                this._select(nextSlideIndex);\n            }), 0);\n        }\n        else {\n            this._slides.remove(remIndex);\n            /** @type {?} */\n            const currentSlideIndex = this.getCurrentSlideIndex();\n            setTimeout((/**\n             * @return {?}\n             */\n            () => {\n                // after removing, need to actualize index of current active slide\n                this._currentActiveSlide = currentSlideIndex;\n                this.activeSlideChange.emit(this._currentActiveSlide);\n            }), 0);\n        }\n    }\n    /**\n     * @param {?=} force\n     * @return {?}\n     */\n    nextSlideFromInterval(force = false) {\n        this.move(Direction.NEXT, force);\n    }\n    /**\n     * Rolling to next slide\n     * @param {?=} force\n     * @return {?}\n     */\n    nextSlide(force = false) {\n        if (this.isPlaying) {\n            this.restartTimer();\n        }\n        this.move(Direction.NEXT, force);\n    }\n    /**\n     * Rolling to previous slide\n     * @param {?=} force\n     * @return {?}\n     */\n    previousSlide(force = false) {\n        if (this.isPlaying) {\n            this.restartTimer();\n        }\n        this.move(Direction.PREV, force);\n    }\n    /**\n     * @return {?}\n     */\n    getFirstVisibleIndex() {\n        return this.slides.findIndex(this.getActive);\n    }\n    /**\n     * @return {?}\n     */\n    getLastVisibleIndex() {\n        return findLastIndex(this.slides, this.getActive);\n    }\n    /**\n     * @param {?} direction\n     * @param {?=} force\n     * @return {?}\n     */\n    move(direction, force = false) {\n        /** @type {?} */\n        const firstVisibleIndex = this.getFirstVisibleIndex();\n        /** @type {?} */\n        const lastVisibleIndex = this.getLastVisibleIndex();\n        if (this.noWrap) {\n            if (direction === Direction.NEXT &&\n                this.isLast(lastVisibleIndex) ||\n                direction === Direction.PREV &&\n                    firstVisibleIndex === 0) {\n                return;\n            }\n        }\n        if (!this.multilist) {\n            this.activeSlide = this.findNextSlideIndex(direction, force);\n        }\n        else {\n            this.moveMultilist(direction);\n        }\n    }\n    /**\n     * Swith slides by enter, space and arrows keys\n     * \\@internal\n     * @param {?} event\n     * @return {?}\n     */\n    keydownPress(event) {\n        // tslint:disable-next-line:deprecation\n        if (event.keyCode === 13 || event.key === 'Enter' || event.keyCode === 32 || event.key === 'Space') {\n            this.nextSlide();\n            event.preventDefault();\n            return;\n        }\n        // tslint:disable-next-line:deprecation\n        if (event.keyCode === 37 || event.key === 'LeftArrow') {\n            this.previousSlide();\n            return;\n        }\n        // tslint:disable-next-line:deprecation\n        if (event.keyCode === 39 || event.key === 'RightArrow') {\n            this.nextSlide();\n            return;\n        }\n    }\n    /**\n     * Play on mouse leave\n     * \\@internal\n     * @return {?}\n     */\n    onMouseLeave() {\n        if (!this.pauseOnFocus) {\n            this.play();\n        }\n    }\n    /**\n     * Play on mouse up\n     * \\@internal\n     * @return {?}\n     */\n    onMouseUp() {\n        if (!this.pauseOnFocus) {\n            this.play();\n        }\n    }\n    /**\n     * When slides on focus autoplay is stopped(optional)\n     * \\@internal\n     * @return {?}\n     */\n    pauseFocusIn() {\n        if (this.pauseOnFocus) {\n            this.isPlaying = false;\n            this.resetTimer();\n        }\n    }\n    /**\n     * When slides out of focus autoplay is started\n     * \\@internal\n     * @return {?}\n     */\n    pauseFocusOut() {\n        this.play();\n    }\n    /**\n     * Rolling to specified slide\n     * @param {?} index\n     * @return {?}\n     */\n    selectSlide(index) {\n        if (this.isPlaying) {\n            this.restartTimer();\n        }\n        if (!this.multilist) {\n            this.activeSlide = this.indicatorsByChunk ? index * this.itemsPerSlide : index;\n        }\n        else {\n            this.selectSlideRange(this.indicatorsByChunk ? index * this.itemsPerSlide : index);\n        }\n    }\n    /**\n     * Starts a auto changing of slides\n     * @return {?}\n     */\n    play() {\n        if (!this.isPlaying) {\n            this.isPlaying = true;\n            this.restartTimer();\n        }\n    }\n    /**\n     * Stops a auto changing of slides\n     * @return {?}\n     */\n    pause() {\n        if (!this.noPause) {\n            this.isPlaying = false;\n            this.resetTimer();\n        }\n    }\n    /**\n     * Finds and returns index of currently displayed slide\n     * @return {?}\n     */\n    getCurrentSlideIndex() {\n        return this._slides.findIndex(this.getActive);\n    }\n    /**\n     * Defines, whether the specified index is last in collection\n     * @param {?} index\n     * @return {?}\n     */\n    isLast(index) {\n        return index + 1 >= this._slides.length;\n    }\n    /**\n     * Defines, whether the specified index is first in collection\n     * @param {?} index\n     * @return {?}\n     */\n    isFirst(index) {\n        return index === 0;\n    }\n    /**\n     * @return {?}\n     */\n    indicatorsSlides() {\n        return this.slides.filter((/**\n         * @param {?} slide\n         * @param {?} index\n         * @return {?}\n         */\n        (slide, index) => !this.indicatorsByChunk || index % this.itemsPerSlide === 0));\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    selectInitialSlides() {\n        /** @type {?} */\n        const startIndex = this.startFromIndex <= this._slides.length\n            ? this.startFromIndex\n            : 0;\n        this.hideSlides();\n        if (this.singleSlideOffset) {\n            this._slidesWithIndexes = this.mapSlidesAndIndexes();\n            if (this._slides.length - startIndex < this.itemsPerSlide) {\n                /** @type {?} */\n                const slidesToAppend = this._slidesWithIndexes.slice(0, startIndex);\n                this._slidesWithIndexes = [\n                    ...this._slidesWithIndexes,\n                    ...slidesToAppend\n                ]\n                    .slice(slidesToAppend.length)\n                    .slice(0, this.itemsPerSlide);\n            }\n            else {\n                this._slidesWithIndexes = this._slidesWithIndexes.slice(startIndex, startIndex + this.itemsPerSlide);\n            }\n            this._slidesWithIndexes.forEach((/**\n             * @param {?} slide\n             * @return {?}\n             */\n            (slide) => slide.item.active = true));\n            this.makeSlidesConsistent(this._slidesWithIndexes);\n        }\n        else {\n            this.selectRangeByNestedIndex(startIndex);\n        }\n        this.slideRangeChange.emit(this.getVisibleIndexes());\n    }\n    /**\n     * Defines next slide index, depending of direction\n     * @private\n     * @param {?} direction\n     * @param {?} force\n     * @return {?}\n     */\n    findNextSlideIndex(direction, force) {\n        /** @type {?} */\n        let nextSlideIndex = 0;\n        if (!force &&\n            (this.isLast(this.activeSlide) &&\n                direction !== Direction.PREV &&\n                this.noWrap)) {\n            return undefined;\n        }\n        switch (direction) {\n            case Direction.NEXT:\n                // if this is last slide, not force, looping is disabled\n                // and need to going forward - select current slide, as a next\n                nextSlideIndex = !this.isLast(this._currentActiveSlide)\n                    ? this._currentActiveSlide + 1\n                    : !force && this.noWrap ? this._currentActiveSlide : 0;\n                break;\n            case Direction.PREV:\n                // if this is first slide, not force, looping is disabled\n                // and need to going backward - select current slide, as a next\n                nextSlideIndex =\n                    this._currentActiveSlide > 0\n                        ? this._currentActiveSlide - 1\n                        : !force && this.noWrap\n                            ? this._currentActiveSlide\n                            : this._slides.length - 1;\n                break;\n            default:\n                throw new Error('Unknown direction');\n        }\n        return nextSlideIndex;\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    mapSlidesAndIndexes() {\n        return this.slides\n            .slice()\n            .map((/**\n         * @param {?} slide\n         * @param {?} index\n         * @return {?}\n         */\n        (slide, index) => {\n            return {\n                index,\n                item: slide\n            };\n        }));\n    }\n    /**\n     * @private\n     * @param {?} index\n     * @return {?}\n     */\n    selectSlideRange(index) {\n        if (this.isIndexInRange(index)) {\n            return;\n        }\n        this.hideSlides();\n        if (!this.singleSlideOffset) {\n            this.selectRangeByNestedIndex(index);\n        }\n        else {\n            /** @type {?} */\n            const startIndex = this.isIndexOnTheEdges(index)\n                ? index\n                : index - this.itemsPerSlide + 1;\n            /** @type {?} */\n            const endIndex = this.isIndexOnTheEdges(index)\n                ? index + this.itemsPerSlide\n                : index + 1;\n            this._slidesWithIndexes = this.mapSlidesAndIndexes().slice(startIndex, endIndex);\n            this.makeSlidesConsistent(this._slidesWithIndexes);\n            this._slidesWithIndexes.forEach((/**\n             * @param {?} slide\n             * @return {?}\n             */\n            (slide) => slide.item.active = true));\n        }\n        this.slideRangeChange.emit(this.getVisibleIndexes());\n    }\n    /**\n     * @private\n     * @param {?} index\n     * @return {?}\n     */\n    selectRangeByNestedIndex(index) {\n        /** @type {?} */\n        const selectedRange = this._chunkedSlides\n            .map((/**\n         * @param {?} slidesList\n         * @param {?} i\n         * @return {?}\n         */\n        (slidesList, i) => {\n            return {\n                index: i,\n                list: slidesList\n            };\n        }))\n            .find((/**\n         * @param {?} slidesList\n         * @return {?}\n         */\n        (slidesList) => {\n            return slidesList.list.find((/**\n             * @param {?} slide\n             * @return {?}\n             */\n            slide => slide.index === index)) !== undefined;\n        }));\n        this._currentVisibleSlidesIndex = selectedRange.index;\n        this._chunkedSlides[selectedRange.index].forEach((/**\n         * @param {?} slide\n         * @return {?}\n         */\n        (slide) => {\n            slide.item.active = true;\n        }));\n    }\n    /**\n     * @private\n     * @param {?} index\n     * @return {?}\n     */\n    isIndexOnTheEdges(index) {\n        return (index + 1 - this.itemsPerSlide <= 0 ||\n            index + this.itemsPerSlide <= this._slides.length);\n    }\n    /**\n     * @private\n     * @param {?} index\n     * @return {?}\n     */\n    isIndexInRange(index) {\n        if (this.singleSlideOffset) {\n            /** @type {?} */\n            const visibleIndexes = this._slidesWithIndexes.map((/**\n             * @param {?} slide\n             * @return {?}\n             */\n            (slide) => slide.index));\n            return visibleIndexes.indexOf(index) >= 0;\n        }\n        return (index <= this.getLastVisibleIndex() &&\n            index >= this.getFirstVisibleIndex());\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    hideSlides() {\n        this.slides.forEach((/**\n         * @param {?} slide\n         * @return {?}\n         */\n        (slide) => slide.active = false));\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    isVisibleSlideListLast() {\n        return this._currentVisibleSlidesIndex === this._chunkedSlides.length - 1;\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    isVisibleSlideListFirst() {\n        return this._currentVisibleSlidesIndex === 0;\n    }\n    /**\n     * @private\n     * @param {?} direction\n     * @return {?}\n     */\n    moveSliderByOneItem(direction) {\n        /** @type {?} */\n        let firstVisibleIndex;\n        /** @type {?} */\n        let lastVisibleIndex;\n        /** @type {?} */\n        let indexToHide;\n        /** @type {?} */\n        let indexToShow;\n        if (this.noWrap) {\n            firstVisibleIndex = this.getFirstVisibleIndex();\n            lastVisibleIndex = this.getLastVisibleIndex();\n            indexToHide = direction === Direction.NEXT\n                ? firstVisibleIndex\n                : lastVisibleIndex;\n            indexToShow = direction !== Direction.NEXT\n                ? firstVisibleIndex - 1\n                : !this.isLast(lastVisibleIndex)\n                    ? lastVisibleIndex + 1 : 0;\n            this._slides.get(indexToHide).active = false;\n            this._slides.get(indexToShow).active = true;\n            /** @type {?} */\n            const slidesToReorder = this.mapSlidesAndIndexes().filter((/**\n             * @param {?} slide\n             * @return {?}\n             */\n            (slide) => slide.item.active));\n            this.makeSlidesConsistent(slidesToReorder);\n            this.slideRangeChange.emit(this.getVisibleIndexes());\n        }\n        else {\n            /** @type {?} */\n            let displayedIndex;\n            firstVisibleIndex = this._slidesWithIndexes[0].index;\n            lastVisibleIndex = this._slidesWithIndexes[this._slidesWithIndexes.length - 1].index;\n            if (direction === Direction.NEXT) {\n                this._slidesWithIndexes.shift();\n                displayedIndex = this.isLast(lastVisibleIndex)\n                    ? 0\n                    : lastVisibleIndex + 1;\n                this._slidesWithIndexes.push({\n                    index: displayedIndex,\n                    item: this._slides.get(displayedIndex)\n                });\n            }\n            else {\n                this._slidesWithIndexes.pop();\n                displayedIndex = this.isFirst(firstVisibleIndex)\n                    ? this._slides.length - 1\n                    : firstVisibleIndex - 1;\n                this._slidesWithIndexes = [{\n                        index: displayedIndex,\n                        item: this._slides.get(displayedIndex)\n                    }, ...this._slidesWithIndexes];\n            }\n            this.hideSlides();\n            this._slidesWithIndexes.forEach((/**\n             * @param {?} slide\n             * @return {?}\n             */\n            slide => slide.item.active = true));\n            this.makeSlidesConsistent(this._slidesWithIndexes);\n            this.slideRangeChange.emit(this._slidesWithIndexes.map((/**\n             * @param {?} slide\n             * @return {?}\n             */\n            (slide) => slide.index)));\n        }\n    }\n    /**\n     * @private\n     * @param {?} direction\n     * @return {?}\n     */\n    moveMultilist(direction) {\n        if (this.singleSlideOffset) {\n            this.moveSliderByOneItem(direction);\n        }\n        else {\n            this.hideSlides();\n            if (this.noWrap) {\n                this._currentVisibleSlidesIndex = direction === Direction.NEXT\n                    ? this._currentVisibleSlidesIndex + 1\n                    : this._currentVisibleSlidesIndex - 1;\n            }\n            else {\n                if (direction === Direction.NEXT) {\n                    this._currentVisibleSlidesIndex = this.isVisibleSlideListLast()\n                        ? 0\n                        : this._currentVisibleSlidesIndex + 1;\n                }\n                else {\n                    this._currentVisibleSlidesIndex = this.isVisibleSlideListFirst()\n                        ? this._chunkedSlides.length - 1\n                        : this._currentVisibleSlidesIndex - 1;\n                }\n            }\n            this._chunkedSlides[this._currentVisibleSlidesIndex].forEach((/**\n             * @param {?} slide\n             * @return {?}\n             */\n            (slide) => slide.item.active = true));\n            this.slideRangeChange.emit(this.getVisibleIndexes());\n        }\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    getVisibleIndexes() {\n        if (!this.singleSlideOffset) {\n            return this._chunkedSlides[this._currentVisibleSlidesIndex]\n                .map((/**\n             * @param {?} slide\n             * @return {?}\n             */\n            (slide) => slide.index));\n        }\n        else {\n            return this._slidesWithIndexes.map((/**\n             * @param {?} slide\n             * @return {?}\n             */\n            (slide) => slide.index));\n        }\n    }\n    /**\n     * Sets a slide, which specified through index, as active\n     * @private\n     * @param {?} index\n     * @return {?}\n     */\n    _select(index) {\n        if (isNaN(index)) {\n            this.pause();\n            return;\n        }\n        if (!this.multilist) {\n            /** @type {?} */\n            const currentSlide = this._slides.get(this._currentActiveSlide);\n            if (currentSlide) {\n                currentSlide.active = false;\n            }\n        }\n        /** @type {?} */\n        const nextSlide = this._slides.get(index);\n        if (nextSlide) {\n            this._currentActiveSlide = index;\n            nextSlide.active = true;\n            this.activeSlide = index;\n            this.activeSlideChange.emit(index);\n        }\n    }\n    /**\n     * Starts loop of auto changing of slides\n     * @private\n     * @return {?}\n     */\n    restartTimer() {\n        this.resetTimer();\n        /** @type {?} */\n        const interval = +this.interval;\n        if (!isNaN(interval) && interval > 0) {\n            this.currentInterval = this.ngZone.runOutsideAngular((/**\n             * @return {?}\n             */\n            () => {\n                return setInterval((/**\n                 * @return {?}\n                 */\n                () => {\n                    /** @type {?} */\n                    const nInterval = +this.interval;\n                    this.ngZone.run((/**\n                     * @return {?}\n                     */\n                    () => {\n                        if (this.isPlaying &&\n                            !isNaN(this.interval) &&\n                            nInterval > 0 &&\n                            this.slides.length) {\n                            this.nextSlideFromInterval();\n                        }\n                        else {\n                            this.pause();\n                        }\n                    }));\n                }), interval);\n            }));\n        }\n    }\n    /**\n     * @return {?}\n     */\n    get multilist() {\n        return this.itemsPerSlide > 1;\n    }\n    /**\n     * Stops loop of auto changing of slides\n     * @private\n     * @return {?}\n     */\n    resetTimer() {\n        if (this.currentInterval) {\n            clearInterval(this.currentInterval);\n            this.currentInterval = void 0;\n        }\n    }\n}\nCarouselComponent.ɵfac = function CarouselComponent_Factory(t) { return new (t || CarouselComponent)(ɵngcc0.ɵɵdirectiveInject(CarouselConfig), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };\nCarouselComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: CarouselComponent, selectors: [[\"carousel\"]], inputs: { indicatorsByChunk: \"indicatorsByChunk\", itemsPerSlide: \"itemsPerSlide\", singleSlideOffset: \"singleSlideOffset\", isAnimated: \"isAnimated\", startFromIndex: \"startFromIndex\", activeSlide: \"activeSlide\", interval: \"interval\", noWrap: \"noWrap\", noPause: \"noPause\", showIndicators: \"showIndicators\", pauseOnFocus: \"pauseOnFocus\" }, outputs: { activeSlideChange: \"activeSlideChange\", slideRangeChange: \"slideRangeChange\" }, ngContentSelectors: _c1, decls: 6, vars: 6, consts: [[\"tabindex\", \"0\", 1, \"carousel\", \"slide\", 3, \"mouseenter\", \"mouseleave\", \"mouseup\", \"keydown\", \"focusin\", \"focusout\"], [\"class\", \"carousel-indicators\", 4, \"ngIf\"], [1, \"carousel-inner\", 3, \"ngStyle\"], [\"class\", \"left carousel-control carousel-control-prev\", \"tabindex\", \"0\", \"role\", \"button\", 3, \"disabled\", \"click\", 4, \"ngIf\"], [\"class\", \"right carousel-control carousel-control-next\", \"tabindex\", \"0\", \"role\", \"button\", 3, \"disabled\", \"click\", 4, \"ngIf\"], [1, \"carousel-indicators\"], [3, \"active\", \"click\", 4, \"ngFor\", \"ngForOf\"], [3, \"click\"], [\"tabindex\", \"0\", \"role\", \"button\", 1, \"left\", \"carousel-control\", \"carousel-control-prev\", 3, \"click\"], [\"aria-hidden\", \"true\", 1, \"icon-prev\", \"carousel-control-prev-icon\"], [\"class\", \"sr-only\", 4, \"ngIf\"], [1, \"sr-only\"], [\"tabindex\", \"0\", \"role\", \"button\", 1, \"right\", \"carousel-control\", \"carousel-control-next\", 3, \"click\"], [\"aria-hidden\", \"true\", 1, \"icon-next\", \"carousel-control-next-icon\"]], template: function CarouselComponent_Template(rf, ctx) { if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵelementStart(0, \"div\", 0);\n        ɵngcc0.ɵɵlistener(\"mouseenter\", function CarouselComponent_Template_div_mouseenter_0_listener() { return ctx.pause(); })(\"mouseleave\", function CarouselComponent_Template_div_mouseleave_0_listener() { return ctx.onMouseLeave(); })(\"mouseup\", function CarouselComponent_Template_div_mouseup_0_listener() { return ctx.onMouseUp(); })(\"keydown\", function CarouselComponent_Template_div_keydown_0_listener($event) { return ctx.keydownPress($event); })(\"focusin\", function CarouselComponent_Template_div_focusin_0_listener() { return ctx.pauseFocusIn(); })(\"focusout\", function CarouselComponent_Template_div_focusout_0_listener() { return ctx.pauseFocusOut(); });\n        ɵngcc0.ɵɵtemplate(1, CarouselComponent_ol_1_Template, 2, 1, \"ol\", 1);\n        ɵngcc0.ɵɵelementStart(2, \"div\", 2);\n        ɵngcc0.ɵɵprojection(3);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵtemplate(4, CarouselComponent_a_4_Template, 3, 3, \"a\", 3);\n        ɵngcc0.ɵɵtemplate(5, CarouselComponent_a_5_Template, 4, 2, \"a\", 4);\n        ɵngcc0.ɵɵelementEnd();\n    } if (rf & 2) {\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.showIndicators && ctx.slides.length > 1);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngStyle\", ɵngcc0.ɵɵpureFunction1(4, _c0, ctx.multilist ? \"flex\" : \"block\"));\n        ɵngcc0.ɵɵadvance(2);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.slides.length > 1);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.slides.length > 1);\n    } }, dependencies: [ɵngcc1.NgForOf, ɵngcc1.NgIf, ɵngcc1.NgStyle], encapsulation: 2 });\n/** @nocollapse */\nCarouselComponent.ctorParameters = () => [\n    { type: CarouselConfig },\n    { type: NgZone }\n];\nCarouselComponent.propDecorators = {\n    noWrap: [{ type: Input }],\n    noPause: [{ type: Input }],\n    showIndicators: [{ type: Input }],\n    pauseOnFocus: [{ type: Input }],\n    indicatorsByChunk: [{ type: Input }],\n    itemsPerSlide: [{ type: Input }],\n    singleSlideOffset: [{ type: Input }],\n    isAnimated: [{ type: Input }],\n    activeSlideChange: [{ type: Output }],\n    slideRangeChange: [{ type: Output }],\n    activeSlide: [{ type: Input }],\n    startFromIndex: [{ type: Input }],\n    interval: [{ type: Input }]\n};\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CarouselComponent, [{\n        type: Component,\n        args: [{\n                selector: 'carousel',\n                template: \"<div (mouseenter)=\\\"pause()\\\"\\n     (mouseleave)=\\\"onMouseLeave()\\\"\\n     (mouseup)=\\\"onMouseUp()\\\"\\n     (keydown)=\\\"keydownPress($event)\\\"\\n     (focusin)=\\\"pauseFocusIn()\\\"\\n     (focusout)=\\\"pauseFocusOut()\\\"\\n     class=\\\"carousel slide\\\" tabindex=\\\"0\\\">\\n  <ol class=\\\"carousel-indicators\\\" *ngIf=\\\"showIndicators && slides.length > 1\\\">\\n    <li *ngFor=\\\"let slide of indicatorsSlides(); let i = index;\\\"\\n        [class.active]=\\\"slide.active === true\\\"\\n        (click)=\\\"selectSlide(i)\\\">\\n    </li>\\n  </ol>\\n  <div class=\\\"carousel-inner\\\" [ngStyle]=\\\"{'display': multilist ? 'flex' : 'block'}\\\">\\n    <ng-content></ng-content>\\n  </div>\\n  <a class=\\\"left carousel-control carousel-control-prev\\\"\\n     [class.disabled]=\\\"activeSlide === 0 && noWrap\\\"\\n     (click)=\\\"previousSlide()\\\" *ngIf=\\\"slides.length > 1\\\"\\n      tabindex=\\\"0\\\" role=\\\"button\\\">\\n    <span class=\\\"icon-prev carousel-control-prev-icon\\\" aria-hidden=\\\"true\\\"></span>\\n    <span *ngIf=\\\"isBs4\\\" class=\\\"sr-only\\\">Previous</span>\\n  </a>\\n  <a class=\\\"right carousel-control carousel-control-next\\\"\\n     [class.disabled]=\\\"isLast(activeSlide) && noWrap\\\"\\n     (click)=\\\"nextSlide()\\\" *ngIf=\\\"slides.length > 1\\\"\\n     tabindex=\\\"0\\\" role=\\\"button\\\">\\n    <span class=\\\"icon-next carousel-control-next-icon\\\" aria-hidden=\\\"true\\\"></span>\\n    <span class=\\\"sr-only\\\">Next</span>\\n  </a>\\n</div>\\n\"\n            }]\n    }], function () { return [{ type: CarouselConfig }, { type: ɵngcc0.NgZone }]; }, { indicatorsByChunk: [{\n            type: Input\n        }], itemsPerSlide: [{\n            type: Input\n        }], singleSlideOffset: [{\n            type: Input\n        }], isAnimated: [{\n            type: Input\n        }], activeSlideChange: [{\n            type: Output\n        }], slideRangeChange: [{\n            type: Output\n        }], startFromIndex: [{\n            type: Input\n        }], activeSlide: [{\n            type: Input\n        }], interval: [{\n            type: Input\n        }], noWrap: [{\n            type: Input\n        }], noPause: [{\n            type: Input\n        }], showIndicators: [{\n            type: Input\n        }], pauseOnFocus: [{\n            type: Input\n        }] }); })();\nif (false) {\n    /** @type {?} */\n    CarouselComponent.prototype.noWrap;\n    /** @type {?} */\n    CarouselComponent.prototype.noPause;\n    /** @type {?} */\n    CarouselComponent.prototype.showIndicators;\n    /** @type {?} */\n    CarouselComponent.prototype.pauseOnFocus;\n    /** @type {?} */\n    CarouselComponent.prototype.indicatorsByChunk;\n    /** @type {?} */\n    CarouselComponent.prototype.itemsPerSlide;\n    /** @type {?} */\n    CarouselComponent.prototype.singleSlideOffset;\n    /**\n     * Turn on/off animation. Animation doesn't work for multilist carousel\n     * @type {?}\n     */\n    CarouselComponent.prototype.isAnimated;\n    /**\n     * Will be emitted when active slide has been changed. Part of two-way-bindable [(activeSlide)] property\n     * @type {?}\n     */\n    CarouselComponent.prototype.activeSlideChange;\n    /**\n     * Will be emitted when active slides has been changed in multilist mode\n     * @type {?}\n     */\n    CarouselComponent.prototype.slideRangeChange;\n    /** @type {?} */\n    CarouselComponent.prototype.startFromIndex;\n    /**\n     * @type {?}\n     * @protected\n     */\n    CarouselComponent.prototype.currentInterval;\n    /**\n     * @type {?}\n     * @protected\n     */\n    CarouselComponent.prototype._currentActiveSlide;\n    /**\n     * @type {?}\n     * @protected\n     */\n    CarouselComponent.prototype._interval;\n    /**\n     * @type {?}\n     * @protected\n     */\n    CarouselComponent.prototype._slides;\n    /**\n     * @type {?}\n     * @protected\n     */\n    CarouselComponent.prototype._chunkedSlides;\n    /**\n     * @type {?}\n     * @protected\n     */\n    CarouselComponent.prototype._slidesWithIndexes;\n    /**\n     * @type {?}\n     * @protected\n     */\n    CarouselComponent.prototype._currentVisibleSlidesIndex;\n    /**\n     * @type {?}\n     * @protected\n     */\n    CarouselComponent.prototype.isPlaying;\n    /**\n     * @type {?}\n     * @protected\n     */\n    CarouselComponent.prototype.destroyed;\n    /** @type {?} */\n    CarouselComponent.prototype.getActive;\n    /**\n     * @type {?}\n     * @private\n     */\n    CarouselComponent.prototype.makeSlidesConsistent;\n    /**\n     * @type {?}\n     * @private\n     */\n    CarouselComponent.prototype.ngZone;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass SlideComponent {\n    /**\n     * @param {?} carousel\n     */\n    constructor(carousel) {\n        this.itemWidth = '100%';\n        this.order = 0;\n        /**\n         * Wraps element by appropriate CSS classes\n         */\n        this.addClass = true;\n        this.carousel = carousel;\n    }\n    /**\n     * Fires changes in container collection after adding a new slide instance\n     * @return {?}\n     */\n    ngOnInit() {\n        this.carousel.addSlide(this);\n        this.itemWidth = `${100 / this.carousel.itemsPerSlide}%`;\n    }\n    /**\n     * Fires changes in container collection after removing of this slide instance\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this.carousel.removeSlide(this);\n    }\n}\nSlideComponent.ɵfac = function SlideComponent_Factory(t) { return new (t || SlideComponent)(ɵngcc0.ɵɵdirectiveInject(CarouselComponent)); };\nSlideComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: SlideComponent, selectors: [[\"slide\"]], hostVars: 13, hostBindings: function SlideComponent_HostBindings(rf, ctx) { if (rf & 2) {\n        ɵngcc0.ɵɵattribute(\"aria-hidden\", !ctx.active);\n        ɵngcc0.ɵɵstyleProp(\"width\", ctx.itemWidth)(\"order\", ctx.order);\n        ɵngcc0.ɵɵclassProp(\"item\", ctx.addClass)(\"carousel-item\", ctx.addClass)(\"active\", ctx.active)(\"carousel-animation\", ctx.isAnimated);\n    } }, inputs: { active: \"active\" }, ngContentSelectors: _c1, decls: 2, vars: 2, consts: [[1, \"item\"]], template: function SlideComponent_Template(rf, ctx) { if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵelementStart(0, \"div\", 0);\n        ɵngcc0.ɵɵprojection(1);\n        ɵngcc0.ɵɵelementEnd();\n    } if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"active\", ctx.active);\n    } }, styles: [\".carousel-animation[_nghost-%COMP%] {\\n       transition: opacity 0.6s ease, visibility 0.6s ease;\\n       float: left;\\n    }\\n    .carousel-animation.active[_nghost-%COMP%] {\\n      opacity: 1;\\n      visibility: visible;\\n    }\\n    .carousel-animation[_nghost-%COMP%]:not(.active) {\\n      display: block;\\n      position: absolute;\\n      opacity: 0;\\n      visibility: hidden;\\n    }\"] });\n/** @nocollapse */\nSlideComponent.ctorParameters = () => [\n    { type: CarouselComponent }\n];\nSlideComponent.propDecorators = {\n    active: [{ type: HostBinding, args: ['class.active',] }, { type: Input }],\n    itemWidth: [{ type: HostBinding, args: ['style.width',] }],\n    order: [{ type: HostBinding, args: ['style.order',] }],\n    isAnimated: [{ type: HostBinding, args: ['class.carousel-animation',] }],\n    addClass: [{ type: HostBinding, args: ['class.item',] }, { type: HostBinding, args: ['class.carousel-item',] }]\n};\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SlideComponent, [{\n        type: Component,\n        args: [{ selector: 'slide', template: `\n    <div [class.active]=\"active\" class=\"item\">\n      <ng-content></ng-content>\n    </div>\n  `, host: {\n                    '[attr.aria-hidden]': '!active'\n                }, styles: [\"\\n    :host.carousel-animation {\\n       transition: opacity 0.6s ease, visibility 0.6s ease;\\n       float: left;\\n    }\\n    :host.carousel-animation.active {\\n      opacity: 1;\\n      visibility: visible;\\n    }\\n    :host.carousel-animation:not(.active) {\\n      display: block;\\n      position: absolute;\\n      opacity: 0;\\n      visibility: hidden;\\n    }\\n  \"] }]\n    }], function () { return [{ type: CarouselComponent }]; }, { itemWidth: [{\n            type: HostBinding,\n            args: ['style.width']\n        }], order: [{\n            type: HostBinding,\n            args: ['style.order']\n        }], addClass: [{\n            type: HostBinding,\n            args: ['class.item']\n        }, {\n            type: HostBinding,\n            args: ['class.carousel-item']\n        }], active: [{\n            type: HostBinding,\n            args: ['class.active']\n        }, {\n            type: Input\n        }], isAnimated: [{\n            type: HostBinding,\n            args: ['class.carousel-animation']\n        }] }); })();\nif (false) {\n    /**\n     * Is current slide active\n     * @type {?}\n     */\n    SlideComponent.prototype.active;\n    /** @type {?} */\n    SlideComponent.prototype.itemWidth;\n    /** @type {?} */\n    SlideComponent.prototype.order;\n    /** @type {?} */\n    SlideComponent.prototype.isAnimated;\n    /**\n     * Wraps element by appropriate CSS classes\n     * @type {?}\n     */\n    SlideComponent.prototype.addClass;\n    /**\n     * Link to Parent(container-collection) component\n     * @type {?}\n     * @protected\n     */\n    SlideComponent.prototype.carousel;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass CarouselModule {\n    /**\n     * @return {?}\n     */\n    static forRoot() {\n        return { ngModule: CarouselModule, providers: [] };\n    }\n}\nCarouselModule.ɵfac = function CarouselModule_Factory(t) { return new (t || CarouselModule)(); };\nCarouselModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: CarouselModule });\nCarouselModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [CommonModule] });\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CarouselModule, [{\n        type: NgModule,\n        args: [{\n                imports: [CommonModule],\n                declarations: [SlideComponent, CarouselComponent],\n                exports: [SlideComponent, CarouselComponent]\n            }]\n    }], null, null); })();\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(CarouselModule, { declarations: function () { return [SlideComponent, CarouselComponent]; }, imports: function () { return [CommonModule]; }, exports: function () { return [SlideComponent, CarouselComponent]; } }); })();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nexport { CarouselComponent, CarouselConfig, CarouselModule, SlideComponent };\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}